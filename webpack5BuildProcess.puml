@startuml
|webpack/bin/webpack.js|
start
:runCLI(cli);

|webpack-cli/lib/bootstrap.js|
:runCLI(args);

|webpack-cli/lib/webpack-cli.js|
:run(args, parseOptions);
:this.program.action(async (options, program) => {});
:loadCommandByName(commandName, allowToInstall);
:this.loadWebpack();
:this.runWebpack(options, isWatchCommand);
:this.createCompiler(options, callback);
:this.webpack(options, callback);

|webpack/lib/webpack.js|
:webpack(options, callback);
:const { compiler, watch, watchOptions } = create();
:compiler = createCompiler(webpackOptions);
:注册自己配置的插件的回调plugin.apply(compiler);
:new WebpackOptionsApply().process(options, compiler)根据我们的配置，会注册对应的内部插件;

|webpack/lib/WebpackOptionsApply.js|
:process(options, compiler) {
    new EntryOptionPlugin().apply(compiler)
    compiler.hooks.entryOption.call(options.context, options.entry)
};

|webpack/lib/EntryOptionPlugin.js|
:apply(compiler) {
    // 订阅compiler entryOption钩子，回调中执行EntryOptionPlugin.applyEntryOption(compiler, context, entry)
};

|webpack/lib/WebpackOptionsApply.js|
:compiler.hooks.entryOption.call(options.context, options.entry) 触发compiler entryOption钩子;
:注册其他内部插件;

|webpack/lib/EntryOptionPlugin.js|
:EntryOptionPlugin.applyEntryOption(compiler, context, entry);
:static applyEntryOption(compiler, context, entry);
:遍历entry,执行new EntryPlugin(context, entry, options).apply(compiler);

|webpack/lib/EntryPlugin.js|
:apply(compiler) {
    // 订阅compiler make钩子，回调中执行compilation.addEntry(context, dep, options, callback)
};

|webpack/lib/webpack.js|
:compiler.run(callback);

|Compiler.js|
:run(callback);
:run.run();
:const run = () => {
    this.compile(onCompiled)
};
:const onCompiled = (err, compilation) => {
    process.nextTick(() => {
       this.emitAssets(compilation, err => {
            this.hooks.done.callAsync(stats, err => {})
       }) 
    })
};
:compile(callback);
:开始创建entry的compilation对象;
:const compilation = this.newCompilation(params);
:newCompilation(params){const compilation = this.createCompilation(params)};
:new Compilation(this, params);

|Compilation.js|
:constructor(compiler, params);

|Compiler.js|
:this.hooks.make.callAsync(compilation, callback);

|webpack/lib/EntryPlugin.js|
:compilation.addEntry(context, dep, options, callback);

|Compilation.js|
:addEntry(context, entry, optionsOrName, callback) {
    this._addEntryItem(context, entry, "dependencies", options, callback)
};
:_addEntryItem(context, entry, target, options, callback) {
    this.addModuleTree({ context, dependency, contextInfo }, callback)
};
:addModuleTree({ context, dependency, contextInfo }, callback) {
    this.handleModuleCreation({factory, dependencies, originModule, contextInfo, context}, callback)
};
:handleModuleCreation({factory, dependencies, originModule, contextInfo, context}, callback) {
    this.factorizeModule({currentProfile,factory,dependencies,factoryResult: true,originModule,contextInfo,context}, callback)
};
:开始创建index.html的compilation对象;
:省略一些步骤...;
:handleModuleCreation({factory, dependencies, originModule, contextInfo, context}, callback) {
    this.factorizeModule({currentProfile,factory,dependencies,factoryResult: true,originModule,contextInfo,context}, callback)
};
:_factorizeModule({currentProfile, factory, dependencies, originModule, factoryResult, contextInfo, context}, callback) {
    factory.create(data, callback)
}

|lib/NormalModuleFactory.js|
:create(data, callback) {
    callback(err, factoryResult)
};

|Compilation.js|
:_factorizeModule(data, callback) {
    factory.create(data, (err, result) => {
        callback(null, factoryResult ? result : result.module)
    })
};
:this.factorizeModule({currentProfile,factory,dependencies,factoryResult: true,originModule,contextInfo,context}, (err, factoryResult) => {
    this.addModule(newModule, (err, module) => {})
});
:_addModule(module, callback){
    callback(null, module)
};
:this.addModule(newModule, (err, module) => {
    this._handleModuleBuildAndDependencies(
        originModule,
        module,
        recursive,
        callback
    )
});
:_handleModuleBuildAndDependencies(originModule, module, recursive, callback) {
    this.buildModule(module, err => {})
};
:_buildModule(module, callback) {
    module.needModule(context, (err, needBuild) => {
        module.build(this.options,this,this.resolverFactory.get("normal", module.resolveOptions),this.inputFileSystem,err => {})
    })
};

|NormalModule.js|
:needBuild(context, callback) {
    return callback(null, true)
};
:build(options, compilation, resolver, fs, callback) {
    return this._doBuild(options, compilation, resolver, fs, hooks, err => {
        let result
        const source = this._source.source()
        result = this.parser.parse(this._ast || source, {
            source,
            current: this,
            module: this,
            compilation: compilation,
            options: options
        })
    })
};
:_doBuild;
note right
_doBuild(options, compilation, resolver, fs, hooks, callback) {
    const processResult = (err, result) => {return callback()}
    runLoaders(options, (err, result) => {
        // loader解析模块为标准js模块
        processResult(err, result.result)
    })
}
end note

|loader-runner/lib/LoaderRunner.js|
:runLoaders(options, callback) {
    callback()
};

|NormalModule.js|
:this._doBuild;
note right
this._doBuild(options, compilation, resolver, fs, hooks, err => {
    let result
    const source = this._source.source()
    // parser.parse 对JS代码进行语法解析,解析成AST语法树
    result = this.parser.parse(this._ast || source, {
        source,
        current: this,
        module: this,
        compilation: compilation,
        options: options
    })
    const handleParseResult = e => {
        return callback()
    }
    ' // 处理ast importDeclation,并添加到module的dependencies中
    handleParseResult(result)
})
end note

|webpack/lib/javascript/JavascriptParser.js|
:parse(source, state) {
    return state
};

|NormalModule.js|
:this._doBuild(..., err => {
    callback()
});

|Compilation.js|
:module.build(this.options,this,this.resolverFactory.get("normal", module.resolveOptions),this.inputFileSystem,err => {callback()});
:this.buildModule(module, err => {
    this.processModuleDependencies(module, err => {
        callback(null, module)
    })
});
:_processModuleDependencies;
note right
_processModuleDependencies(module, callbak) {
    遍历module.dependencies,将dep转换为module
    for (const item of sortedDependencies) {
        inProgressTransitive++;
        this.handleModuleCreation(item, err => {})
    }
}
end note
:handleModuleCreation() {
    // 重复上面创建module的步骤
};
:所有module创建完毕;

|Compiler.js|
:compile(callback) {
    // make阶段执行完毕，接着调用compilation.seal
    compilation.seal(err => {
        return callback(null, compilation)
    })
};
:seal(callback) {
    // todo
};




@enduml